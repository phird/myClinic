{
  "version": 3,
  "sources": ["../../@casl/react/src/Can.ts", "../../@casl/react/src/factory.ts", "../../@casl/react/src/hooks/useAbility.ts"],
  "sourcesContent": ["import { PureComponent, ReactNode } from 'react';\nimport {\n  Unsubscribe,\n  AbilityTuple,\n  SubjectType,\n  AnyAbility,\n  Generics,\n  Abilities,\n  IfString,\n} from '@casl/ability';\n\nconst noop = () => {};\n\ntype AbilityCanProps<\n  T extends Abilities,\n  Else = IfString<T, { do: T } | { I: T }>\n> = T extends AbilityTuple\n  ? { do: T[0], on: T[1], field?: string } |\n  { I: T[0], a: Extract<T[1], SubjectType>, field?: string } |\n  { I: T[0], an: Extract<T[1], SubjectType>, field?: string } |\n  { I: T[0], this: Exclude<T[1], SubjectType>, field?: string }\n  : Else;\n\ninterface ExtraProps {\n  not?: boolean\n  passThrough?: boolean\n}\n\ninterface CanExtraProps<T extends AnyAbility> extends ExtraProps {\n  ability: T\n  children: ReactNode | ((isAllowed: boolean, ability: T) => ReactNode)\n}\n\ninterface BoundCanExtraProps<T extends AnyAbility> extends ExtraProps {\n  ability?: T\n  children: ReactNode | ((isAllowed: boolean, ability: T) => ReactNode)\n}\n\nexport type CanProps<T extends AnyAbility> =\n  AbilityCanProps<Generics<T>['abilities']> & CanExtraProps<T>;\nexport type BoundCanProps<T extends AnyAbility> =\n  AbilityCanProps<Generics<T>['abilities']> & BoundCanExtraProps<T>;\n\nexport class Can<\n  T extends AnyAbility,\n  IsBound extends boolean = false\n> extends PureComponent<IsBound extends true ? BoundCanProps<T> : CanProps<T>> {\n  private _isAllowed: boolean = false;\n  private _ability: T | null = null;\n  private _unsubscribeFromAbility: Unsubscribe = noop;\n\n  componentWillUnmount() {\n    this._unsubscribeFromAbility();\n  }\n\n  private _connectToAbility(ability?: T) {\n    if (ability === this._ability) {\n      return;\n    }\n\n    this._unsubscribeFromAbility();\n    this._ability = null;\n\n    if (ability) {\n      this._ability = ability;\n      this._unsubscribeFromAbility = ability.on('updated', () => this.forceUpdate());\n    }\n  }\n\n  get allowed() {\n    return this._isAllowed;\n  }\n\n  private _canRender(): boolean {\n    const props: any = this.props;\n    const subject = props.of || props.a || props.an || props.this || props.on;\n    const can = props.not ? 'cannot' : 'can';\n\n    return props.ability[can](props.I || props.do, subject, props.field);\n  }\n\n  render() {\n    this._connectToAbility(this.props.ability);\n    this._isAllowed = this._canRender();\n    return this.props.passThrough || this._isAllowed ? this._renderChildren() : null;\n  }\n\n  private _renderChildren() {\n    const { children, ability } = this.props;\n    const elements = typeof children === 'function'\n      ? children(this._isAllowed, ability as any)\n      : children;\n\n    return elements as ReactNode;\n  }\n}\n", "import { createElement as h, ComponentClass, Consumer, FunctionComponent } from 'react';\nimport { AnyAbility } from '@casl/ability';\nimport { Can, BoundCanProps } from './Can';\n\ninterface BoundCanClass<T extends AnyAbility> extends ComponentClass<BoundCanProps<T>> {\n  new (props: BoundCanProps<T>, context?: any): Can<T, true>\n}\n\nexport function createCanBoundTo<T extends AnyAbility>(ability: T): BoundCanClass<T> {\n  return class extends Can<T, true> {\n    static defaultProps = { ability } as BoundCanClass<T>['defaultProps'];\n  };\n}\n\nexport function createContextualCan<T extends AnyAbility>(\n  Getter: Consumer<T>\n): FunctionComponent<BoundCanProps<T>> {\n  return (props: BoundCanProps<T>) => h(Getter, {\n    children: (ability: T) => h(Can, {\n      ability,\n      ...props,\n    } as any)\n  });\n}\n", "import React from 'react';\nimport { AnyAbility } from '@casl/ability';\n\nexport function useAbility<T extends AnyAbility>(context: React.Context<T>): T {\n  if (process.env.NODE_ENV !== 'production' && typeof React.useContext !== 'function') {\n    /* istanbul ignore next */\n    throw new Error('You must use React >= 16.8 in order to use useAbility()');\n  }\n\n  const ability = React.useContext<T>(context);\n  const [rules, setRules] = React.useState<T['rules']>();\n\n  React.useEffect(() => ability.on('updated', (event) => {\n    if (event.rules !== rules) {\n      setRules(event.rules);\n    }\n  }), []);\n\n  return ability;\n}\n"],
  "mappings": "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",
  "names": ["noop", "Can", "_isAllowed", "n", "_ability", "_unsubscribeFromAbility", "componentWillUnmount", "t", "_connectToAbility", "ability", "this", "on", "_this2", "forceUpdate", "_canRender", "props", "subject", "of", "a", "an", "can", "not", "I", "do", "field", "render", "passThrough", "_renderChildren", "r", "children", "elements", "PureComponent", "createCanBoundTo", "defaultProps", "createContextualCan", "Getter", "h", "useAbility", "context", "React", "useContext", "Error", "useState", "rules", "setRules", "useEffect", "event"]
}

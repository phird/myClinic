import {
  init_buffer,
  init_virtual_process_polyfill
} from "./chunk-6JVGITVI.js";

// node_modules/prismjs/components/prism-jsx.min.js
init_virtual_process_polyfill();
init_buffer();
!function(t) {
  var n = t.util.clone(t.languages.javascript), e = "(?:\\{<S>*\\.{3}(?:[^{}]|<BRACES>)*\\})";
  function a(t2, n2) {
    return t2 = t2.replace(/<S>/g, function() {
      return "(?:\\s|//.*(?!.)|/\\*(?:[^*]|\\*(?!/))\\*/)";
    }).replace(/<BRACES>/g, function() {
      return "(?:\\{(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])*\\})";
    }).replace(/<SPREAD>/g, function() {
      return e;
    }), RegExp(t2, n2);
  }
  e = a(e).source, t.languages.jsx = t.languages.extend("markup", n), t.languages.jsx.tag.pattern = a(`</?(?:[\\w.:-]+(?:<S>+(?:[\\w.:$-]+(?:=(?:"(?:\\\\[^]|[^\\\\"])*"|'(?:\\\\[^]|[^\\\\'])*'|[^\\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*/?)?>`), t.languages.jsx.tag.inside.tag.pattern = /^<\/?[^\s>\/]*/, t.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/, t.languages.jsx.tag.inside.tag.inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/, t.languages.jsx.tag.inside.comment = n.comment, t.languages.insertBefore("inside", "attr-name", { spread: { pattern: a("<SPREAD>"), inside: t.languages.jsx } }, t.languages.jsx.tag), t.languages.insertBefore("inside", "special-attr", { script: { pattern: a("=<BRACES>"), alias: "language-javascript", inside: { "script-punctuation": { pattern: /^=(?=\{)/, alias: "punctuation" }, rest: t.languages.jsx } } }, t.languages.jsx.tag);
  var s = function(t2) {
    return t2 ? "string" == typeof t2 ? t2 : "string" == typeof t2.content ? t2.content : t2.content.map(s).join("") : "";
  }, g = function(n2) {
    for (var e2 = [], a2 = 0; a2 < n2.length; a2++) {
      var o = n2[a2], i = false;
      if ("string" != typeof o && ("tag" === o.type && o.content[0] && "tag" === o.content[0].type ? "</" === o.content[0].content[0].content ? e2.length > 0 && e2[e2.length - 1].tagName === s(o.content[0].content[1]) && e2.pop() : "/>" === o.content[o.content.length - 1].content || e2.push({ tagName: s(o.content[0].content[1]), openedBraces: 0 }) : e2.length > 0 && "punctuation" === o.type && "{" === o.content ? e2[e2.length - 1].openedBraces++ : e2.length > 0 && e2[e2.length - 1].openedBraces > 0 && "punctuation" === o.type && "}" === o.content ? e2[e2.length - 1].openedBraces-- : i = true), (i || "string" == typeof o) && e2.length > 0 && 0 === e2[e2.length - 1].openedBraces) {
        var r = s(o);
        a2 < n2.length - 1 && ("string" == typeof n2[a2 + 1] || "plain-text" === n2[a2 + 1].type) && (r += s(n2[a2 + 1]), n2.splice(a2 + 1, 1)), a2 > 0 && ("string" == typeof n2[a2 - 1] || "plain-text" === n2[a2 - 1].type) && (r = s(n2[a2 - 1]) + r, n2.splice(a2 - 1, 1), a2--), n2[a2] = new t.Token("plain-text", r, null, r);
      }
      o.content && "string" != typeof o.content && g(o.content);
    }
  };
  t.hooks.add("after-tokenize", function(t2) {
    "jsx" !== t2.language && "tsx" !== t2.language || g(t2.tokens);
  });
}(Prism);
//# sourceMappingURL=prismjs_components_prism-jsx__min.js.map
